#==============================================================================
# Rules for creating MSVC project files.
# Copyright (C) 2004 by Eric Sunshine <sunshine@sunshineco.com>
#
#    This library is free software; you can redistribute it and/or modify it
#    under the terms of the GNU Library General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or (at your
#    option) any later version.
#
#    This library is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
#    License for more details.
#
#    You should have received a copy of the GNU Library General Public License
#    along with this library; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#==============================================================================
#
# During a project file synthesis run, the property name 'projgen' in the
# container 'build' will be given a value describing which type of project
# files are being generated. For MSVC project files, the value of the 'projgen'
# property will be "msvc". When project file synthesis supports multiple tool
# versions, the 'projgen_version' property will have a value indicating the
# version of the tool for which project files are being created. For instance,
# when generating MSVC7 project files, 'projgen' will be set to "msvc" and
# 'projgen_version' will have the value "7".
#
# Jamfiles throughout the project, if they need to alter their behavior (for
# one reason or another), can invoke the Property rule to determine whether
# project files are being synthesized.  For example, to learn if project file
# synthesis is active:
#
# if [ Property build : projgen ] { ... do something ... }
#
# To take action if only a particular type of project file is being generated
# (i.e. "msvc"):
#
# if [ Property build : projgen ] = msvc { ... do something ... }
#
#==============================================================================

MSVCGEN_SUPPORTED_VERSIONS = 6 7 71 8 9 10 ;
MSVCGEN_BUILD_ROOT ?= [ ConcatDirs $(BUILDTOP) out ] ;
MSVCGEN_BUILD_TEMP ?= [ ConcatDirs $(MSVCGEN_BUILD_ROOT) msvcgen ] ;

#------------------------------------------------------------------------------
# Public rule stubs. May be implemented by msvcgen phase 1 or phase 2 or both.

## MsvcGenConfig variable [ : value ]
##   Specify additional configuration information to augment the msvcgen
##   environment.  The Jam variable named by 'variable' is set to 'value' for
##   the msvcgen run.  If 'value' is omitted, then 'variable' is cleared.
##   Invocations of MsvcGenConfig are cumulative, so variable/value tuples can
##   be provided incrementally.  It is legal to use this rule in conjunction
##   with MsvcGenConfigFile; they are not mutually exclusive.
##
##   The most common reason to invoke this rule is to provide MSVC-specific
##   fallback values for the library checks typically performed by an Autoconf
##   configure script, which the Jamfiles reference via the ExternalLibs rule.
##   Such fallbacks consist of variables named TAG.CFLAGS, TAG.LFLAGS, and
##   TAG.LIBS, where TAG represents the library's identifier exported by the
##   configure script.  Because project generation allows for finer-grained
##   control, you can also optionally set the variables TAG.DEFINES,
##   TAG.INCDIRS, and TAG.LIBDIRS.  TAG.DEFINES is a set of tokens of the form
##   "key" or "key=value".  For instance, to provide MSVC-specific fallback
##   values for the FreeType2 library, which the configure script might
##   identify as FT2, you can define variables named FT2.CFLAGS, FT2.LFLAGS,
##   FT2.LIBS, FT2.DEFINES, FT2.INCDIRS, and FT2.LIBDIRS.  The msvcgen process
##   will consult these variables when it encounters invocations of the
##   ExternalLibs rule, and apply the overrides to the generated project files.
##   If yours is a multi-platform project which conditionally defines
##   Application, Plugin, and Library targets based upon the platform, then you
##   should also define whatever additional variables or properties are needed
##   to ensure that your project's Jamfiles invoke the Application, Plugin, and
##   Library rules for modules suitable for Windows, and that they do not
##   invoke those rules for modules specific to other platforms.
rule MsvcGenConfig { MsvcGenConfig1 $(1) : $(2) ; }
rule MsvcGenConfig1 { }

## MsvcGenConfigFile file
##   Similar to MsvcGenConfig, except that the configuration is provided via a
##   file containing Jam statements.  In the common case, the file will contain
##   a series of simple Jam variable assignment statements.  May be invoked
##   multiple times to specify additional configuration files.  It is legal to
##   use this rule in conjunction with MsvcGenConfig; they are not mutually
##   exclusive.
rule MsvcGenConfigFile { MsvcGenConfigFile1 $(1) : $(2) ; }
rule MsvcGenConfigFile1 { }

## MsvcGenVariable variable [ : value ]
##   Define a variable for direct interpolation into msvcgen template files.
##   'variable' is the name of the variable to define.  'value' is the value
##   which should be assigned to 'variable'.  If 'value' is omitted, then
##   'variable' is defined as the null (empty) string.  You may invoke this
##   rule multiple times to define any number of interpolation variables.  You
##   may also invoke it multiple times for the same variable name to give the
##   variable multiple values.  In the template file, reference the variable as
##   `[% variable.0 %]' to retrieve the first element, `[% variable.1 %]' to
##   retrieve the second, and so on.  Even if you have only invoked this rule
##   once for a variable, you must still reference it in the template as
##   `[% variable.0 %]'. If the variable has multiple values, then it is common
##   to reference it in the template via a FOREACH loop, as in
##   `[% FOREACH v IN variable %]'.
rule MsvcGenVariable { MsvcGenVariable1 $(1) : $(2) ; }
rule MsvcGenVariable1 { }

## MsvcGenWorkspace name [ : accepts [ : rejects ]]
##   Specify the name of a workspace which the 'msvcgen' target should create.
##   The generated workspace file name will be prefixed by "wks".  By default,
##   a workspace contains all projects resulting from invocations of the
##   Application, Plugin, Library, and CompileGroups rules. It is possible to
##   restrict the projects placed into the workspace by providing the optional
##   'accepts' and/or 'rejects'. These are lists of Perl regular expressions
##   matched against the project names. (Project names are composed of "app",
##   "plg", "lib", and "grp" prepended to the target name given to the
##   Application, Plugin, Library, and CompileGroups rules, respectively.)
##   Reject patterns take precedence over accept patterns.  This rule must be
##   invoked before any invocations of Application, Plugin, Library, or
##   CompileGroups.  You may invoke this rule multiple times to produce
##   multiple workspaces, but you must invoke it at least once in order for the
##   'msvcgen' target to produce any output.
rule MsvcGenWorkspace { MsvcGenWorkspace1 $(1) : $(2) : $(3) ; }
rule MsvcGenWorkspace1 { }

## MsvcGenSubDir dircomponents [ : version ]
##   Invoke this rule with the location of the project file directory as a
##   whitepace-delimited set of tokens, much as you would the SubDir rule.
##   This information is used in two ways.  (1) The directory structure for the
##   generated files will be duplicated under $(MSVCGEN_BUILD_ROOT).  For
##   instance, if your project files are at "$(TOP)/proj/msvc", then the
##   generated files will be deposited at "$(MSVCGEN_BUILD_ROOT)/proj/msvc".
##   (2) The depth of the directory indicated by 'dircomponents' will be taken
##   into account when generating references to resources in your project tree.
##   For example, if your project files reside at "$(TOP)/proj/msvc", and you
##   have set "$(TOP)/resources/game.ico" as the application icon with the
##   ApplicationIconDefault or ApplicationIcon rule, then msvcgen will know
##   that game.ico can be found relative to the project file directory via the
##   path "../../resources/game.ico".  If 'version' is specified, then
##   'dircomponents' applies to generated files for that version of MSVC only.
##   If 'version' is not specified, then the path will be composed of
##   'dircomponents' and the version number.  For instance, if 'dircomponents'
##   is "$(TOP)/proj/msvc" and 'version' was not provided, then it will be
##   assumed that MSVC7 project files should reside at $(TOP)/proj/msvc7".  You
##   must invoke this rule at least once to ensure that 'msvcgen' targets are
##   made available for user invocation.
rule MsvcGenSubDir { msvcgen_path_version MsvcGenSubDir1 : $(1) : $(2) ; }
rule MsvcGenSubDir1 { }

## MsvcGenTemplateDir dircomponents
##   Invoke this rule with the location of the msvcgen template directory as a
##   whitepace-delimited set of tokens.
rule MsvcGenTemplateDir { MsvcGenTemplateDir1 $(1) ; }
rule MsvcGenTemplateDir1 { }

## MsvcExternalLibrary target [ : libs [ : mode [ : arch ]]]
##   Invoke this rule to link 'target' with one or more MSVC-specific external
##   libraries.  For example, 'libs' might be "wsock32.lib".  'mode' should be
##   "release" or "debug". If 'mode' is omitted, then 'libs' is used for
##   release and debug. 'arch' should be "x86" or "x64". If 'arch' is omitted,
##   then 'directories' is used for x86 and x64.
rule MsvcExternalLibrary { MsvcExternalLibrary1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcExternalLibrary1 { }

## MsvcDefine target [ : key [ : value [ : mode [ : arch ]]]]
##   Invoke this rule to define an MSVC-specific preprocessor macro 'key'
##   having 'value' for 'target'.  'mode' should be "release" or "debug". If
##   'mode' is omitted, then 'key/value' is used for release and debug.
##   'arch' should be "x86" or "x64". If 'arch' is omitted, then 'directories'
##   is used for x86 and x64.
rule MsvcDefine { MsvcDefine1 $(1) : $(2) : $(3) : $(4) : $(5) ; }
rule MsvcDefine1 { }

## MsvcIncDirs target : directories [ : mode [ : arch ]]
##   Invoke this rule to define MSVC-specific additional include directories.
##   'target' can be omitted in which case the include directories are added
##   to all MSVC projects.
##   'mode' should be "release" or "debug". If 'mode' is omitted, then 
##   'directories' is used for release and debug. 'arch' should be "x86"
##   or "x64". If 'arch' is omitted, then 'directories' is used for x86 and
##   x64.
rule MsvcIncDirs { MsvcIncDirs1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcIncDirs1 { }

## MsvcCFlags target [ : cflags [ : mode [ : arch ]]]
##   Invoke this rule to set additional MSVC-specific compiler flags for
##   'target'.  'mode' should be "release" or "debug". If 'mode' is omitted,
##   then 'cflags' is used for release and debug. 'arch' should be "x86" or
##   "x64". If 'arch' is omitted, then 'cflags' is used for x86 and x64.
rule MsvcCFlags { MsvcCFlags1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcCFlags1 { }

## MsvcLibDirs target : libdirs [ : mode [ : arch ]]
##   Invoke this rule to define MSVC-specific additional library directories.
##   'target' can be omitted in which case the library directories are added
##   to all MSVC projects.
##   'mode' should be "release" or "debug". If 'mode' is omitted, then 
##   'libdirs' is used for release and debug. 'arch' should be "x86"
##   or "x64". If 'arch' is omitted, then 'libdirs' is used for x86 and x64.
rule MsvcLibDirs { _MsvcLibDirs $(1) : $(2) : $(3) : $(4) ; }
rule _MsvcLibDirs { }

## MsvcLFlags target [ : lflags [ : mode [ : arch ]]]
##   Invoke this rule to set additional MSVC-specific linker flags for
##   'target'.  'mode' should be "release" or "debug". If 'mode' is omitted,
##   then 'lflags' is used for release and debug. 'arch' should be "x86" or
##   "x64". If 'arch' is omitted, then 'lflags' is used for x86 and x64.
rule MsvcLFlags { MsvcLFlags1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcLFlags1 { }

## MsvcExtraFile target : files
##   Use this rule to add extra file resources to the "Resource files" 
##   filter of the generated project. Commonly, those files are auxiliary
##   files not specified in the source file list, e.g. ".inc" files.
rule MsvcExtraFile { MsvcExtraFile1 $(1) : $(2) ; }
rule MsvcExtraFile1 { }

## MsvcGenName target : name
##   Assign an MSVC project name to 'target'.  Normally, the project name is
##   'target' with a prefix of "app", "grp", "lib", "plg", or "wks", depending
##   upon the target's type.  The MsvcGenName rule allows you to override the
##   default name.  This rule must be invoked prior to the Application,
##   Library, Plugin, or MsvcGenWorkspace rule for 'target' in order for 'name'
##   to be accepted.  As an alternative to invoking this rule, if you wish to
##   change the default prefixes used by all targets you can use the MsvcConfig
##   rule to set the MSVC.PREFIX.appcon, MSVC.PREFIX.appgui, MSVC.PREFIX.group,
##   MSVC.PREFIX.library_shared, MSVC.PREFIX.library_static, MSVC.PREFIX.plugin,
##   and MSVC.PREFIX.workspace variables to whatever values you like.
rule MsvcGenName { MsvcGenName1 $(1) : $(2) ; }
rule MsvcGenName1 { }

## MsvcUsePCH target : file
##   Use this rule to set the 'target' to use precompiled header with name 
##   'file'.
rule MsvcUsePCH { MsvcUsePCH1 $(1) : $(2) ; }
rule MsvcUsePCH1 { }

## MsvcParallelCompile target
##   Enable MSVC parallel compilation for a specific target. Useful for targets
##   that are usually build without any concurrency (e.g. because they are a
##   dependency of many other targets).
##   Takes care of only enabling the feature when supported by compiler and
##   build mode.
rule MsvcParallelCompile 
{
# Pad the given VC version with zeroes for comparison purposes.
  local padded_vcver ;
  if "$(MSVC_VERSION)" = "71"
  {
    padded_vcver = "071" ;
  }
  else if [ Match ^([0-9][0-9])$ : $(MSVC_VERSION) ]
  {
    padded_vcver = "$(MSVC_VERSION)0" ;
  }
  else if [ Match ^([0-9])$ : $(MSVC_VERSION) ]
  {
    padded_vcver = "0$(MSVC_VERSION)0" ;
  }
  else
    padded_vcver = "$(MSVC_VERSION)" ;

  if $(padded_vcver) >= 090
  {
    # Enable compiler-provided multithreading.
    # Only enable in release build as the feature is incompatible with certain
    # flags used in debug mode.
    # Also, feature is only available on VC 9.0 and later.
    MsvcCFlags $(1) : /MP : release ;
  }
}

## "Properties" system
## Properties are values attached to msvcgen project types or targets. Some
## properties have a special meaning to the msvcgen process, but otherwise
## properties can be arbitrarily specified. 
## One notable facility is that "properties" can be mapped to variables passed
## down to the templates when instanciated into actual projects, thus allowing
## for a wide-reaching customizations of the generated project.

## MsvcGetTypeProp type : property
##   Get a property of a project type
rule MsvcGetTypeProp { return [ MsvcGetTypeProp1 $(1) : $(2) ] ; }
rule MsvcGetTypeProp1 { }
## MsvcSetTypeProp type : property
##   Set a property of a project type
rule MsvcSetTypeProp { MsvcSetTypeProp1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcSetTypeProp1 { }
## MsvcGetTypeProp type : property
##   Get a property of a target. Queries the property from the project's type
##   if not present in the target.
rule MsvcGetTargetProp { return [ MsvcGetTargetProp1 $(1) : $(2) ] ; }
rule MsvcGetTargetProp1 { }
## MsvcGetTypeProp type : property
##   Set a property of a target
rule MsvcSetTargetProp { MsvcSetTargetProp1 $(1) : $(2) : $(3) : $(4) ; }
rule MsvcSetTargetProp1 { }

## MsvcRegisterVariableProp variable : property
##   Map the property 'property' of targets to the template variable
##   'variable'.
rule MsvcRegisterVariableProp { MsvcRegisterVariableProp1  $(1) : $(2) ; }
rule MsvcRegisterVariableProp1 { }

# Path from build work dir (e.g. out/debug8/libfoo/) to source root
rule MsvcWorkbuildToRoot { return [ ConcatDirs $(DOTDOT) $(DOTDOT) ] ; }

#------------------------------------------------------------------------------
# Private utility rules. Common to all phases.

## msvcgen_path_version rule : dircomponents [ : version ]
##   If 'version' is provided, invoke 'rule' once with 'dircomponents' and
##   'version' as arguments.  If 'version' is not provided, invoke 'rule' once
##   per supported MSVC version with 'dircomponents' augmented so that
##   'version' is appended to the very last element of 'dircomponents'.  For
##   example, if 'version' is omitted, and 'dircomponents' is "TOP proj msvc",
##   then 'rule' will be invoked as "rule TOP proj msvc6 : 6", then "rule TOP
##   proj msvc7 : 7", etc.
rule msvcgen_path_version
{
  local subrule = $(1) ;
  local path = $(2) ;
  local version = $(3) ;
  if $(version)
  {
    msvcgen_version_check $(version) ;
    $(subrule) $(path) : $(version) ;
  }
  else
  {
    local v ;
    for v in $(MSVCGEN_SUPPORTED_VERSIONS)
    {
      local p = [ FReverse $(path) ] ;
      $(subrule) [ FReverse $(p[1])$(v) $(p[2-]) ] : $(v) ;
    }
  }
}

rule msvcgen_resolve_dir
{ return $($(<[1])) $(<[2-]) ; }
rule msvcgen_target_dir
{ return [ ConcatDirs $(MSVCGEN_BUILD_ROOT) $(<[2-]) ] ; }
rule msvcgen_build_dir
{ return [ ConcatDirs $(MSVCGEN_BUILD_TEMP) build$(<) ] ; }
rule msvcgen_work_dir
{ return [ ConcatDirs $(MSVCGEN_BUILD_TEMP) temp$(<) ] ; }
rule msvcgen_template_dir
{ return [ ConcatDirs [ msvcgen_resolve_dir $(<) ] ] ; }
rule msvcgen_version_check
{
  if $(<) != common && ! [ IsElem $(<) : $(MSVCGEN_SUPPORTED_VERSIONS) ]
  {
    exit "Error: `$(<)' is not a supported msvcgen version number; valid "
      "numbers are:" $(MSVCGEN_SUPPORTED_VERSIONS) ;
  }
}

rule MsvcRmTemps
{
  if $(MSVCGEN_KEEPTEMPS) != yes
  {
    RmTemps $(<) : $(>) ;
  }
}

#------------------------------------------------------------------------------
# Phase 1

if ! $(DO_MSVCGEN)
{
JAM ?= jam ;
MSVCGEN_JAMOPTIONS ?= ;
MSVCGEN_TTREEOPTIONS ?= ;
MSVCGEN_SILENT ?= no ;
MSVCGEN_VERBOSE ?= no ;
MSVCGEN_KEEPTEMPS ?= no ;
if $(MSVCGEN_SILENT) = yes
{
  MSVCGEN_JAMOPTIONS += -d0 ;
}
else
{
  MSVCGEN_TTREEOPTIONS += "--verbose" ;
  if $(MSVCGEN_VERBOSE) = yes
  {
    if $(JAMVERSION) <= 2.4
    {
      MSVCGEN_JAMOPTIONS += -d+2 ;
    }
    else
    {
      MSVCGEN_JAMOPTIONS += -d5 ;
    }
  }
}
if $(MSVCGEN_KEEPTEMPS) = yes
{
  MSVCGEN_JAMOPTIONS += "-sMSVCGEN_KEEPTEMPS=yes" ;
}

## MsvcGenConfigFile file
##   (See documentation above.)
rule MsvcGenConfigFile1
{
  MSVCGEN_CONFIG_FILES += $(<) ;
}

## MsvcGenSubDir dircomponents [ : version ]
##   (See documentation above.)
rule MsvcGenSubDir1
{
  local path = $(1) ;
  local version = $(2) ;
  if ! [ Property msvcgen : pathset$(version) ]
  {
    SetProperty msvcgen : pathset$(version) ;
    MsvcGenTarget $(path) : $(version) ;
  }
  else
  {
    Echo "Warning: MsvcGenSubDir already invoked for version $(version)" ;
  }
}

## MsvcGenTarget dircomponents : version
##   Create pseudo-targets for building and removing project files for the
##   specified version of MSVC.  'dircomponents' is interpreted as described
##   for the MsvcGenSubDir rule.  Also populates the list MSVCGEN_TARGETS with
##   names of the targets.  Clients which need to perform some pre-processing
##   prior to the actual msvcgen run may set the targets in this list to depend
##   upon client-supplied targets.
rule MsvcGenTarget
{
  local path = $(1) ;
  local version = $(2) ;
  if $(version) = common
  {
    CleanDir msvccommonclean : [ msvcgen_target_dir $(path) ] ;
    Depends msvcclean : msvccommonclean ;
  }
  else
  {
    MsvcGenUmbrella ;
    Always msvc$(version)gen ;
    NotFile msvc$(version)gen ;
    MSVC_VERSION on msvc$(version)gen = $(version) ;
    MsvcGen msvc$(version)gen ;
    Depends msvcgen : msvc$(version)gen ;
    Help msvc$(version)gen : "Create MSVC$(version) project files" ;
    MSVCGEN_TARGETS += msvc$(version)gen ;
    local commonworkdir = [ msvcgen_work_dir common ] ;
    CleanDir msvc$(version)clean :
      [ msvcgen_target_dir $(path) ]
      [ msvcgen_build_dir $(version) ]
      [ msvcgen_work_dir $(version) ] 
      $(commonworkdir) ;
    Depends msvcclean : msvc$(version)clean ;
    Help msvc$(version)clean : "Remove built MSVC$(version) project files" ;
  }
}

actions MsvcGen bind MSVCGEN_CONFIG_FILES
{
  $(JAM) $(MSVCGEN_JAMOPTIONS) \
    -sDO_MSVCGEN=yes \
    -sMSVC_VERSION=$(MSVC_VERSION) \
    -sMSVCGEN_TTREEOPTIONS='$(MSVCGEN_TTREEOPTIONS)' \
    -sMSVCGEN_CONFIG_FILES='$(MSVCGEN_CONFIG_FILES)' \
    -sTARGET.OS=WIN32 \
    msvcgen
}

## MsvcGenUmbrella
##   Create pseudo-targets for building and removing project files for all
##   version of MSVC.
rule MsvcGenUmbrella
{
  if ! [ Property msvcgen : umbrella ]
  {
    SetProperty msvcgen : umbrella ;

    Always msvcgen ;
    NotFile msvcgen ;
    Help msvcgen : "Create MSVC project files (all versions)" ;

    Always msvcclean ;
    NotFile msvcclean ;
    Help msvcclean : "Remove built MSVC project files (all versions)" ;
    CleanDir msvcclean : $(MSVCGEN_BUILD_TEMP) ;
    Depends clean : msvcclean ;
  }
}

}
else
{

#------------------------------------------------------------------------------
# Phase 2

if $(MSVCGEN_CONFIG_FILES)
{
  local f ;
  for f in $(MSVCGEN_CONFIG_FILES)
  {
    include $(f) ;
  }
}

if $(TTREE)
{
  PERL ?= perl ;
  RUN_TTREE ?= $(PERL) "\"$(TTREE)\"" ;
}
else
{
  TTREE ?= ttree ;
  RUN_TTREE ?= $(TTREE) ;
}

# Implementation note: The --strip-root directives are order-sensitive when the
# build directory is the same as the source directory, in which case TOP is "."
# and MSVCGEN_BUILD_ROOT is "./out".  If TOP incorrectly appeared first, then
# it would invalidate the following --strip-root option since TOP is a prefix
# of MSVCGEN_BUILD_ROOT.
MSVCGEN_STRIP_ROOT = $(MSVCGEN_BUILD_ROOT)/ $(TOP)/ ;

# When generating the icon file .rc, we compose a 'sed' expression out of
# MSVCGEN_BUILD_ROOT in order to ensure that the referenced icon paths are
# correct. However, we must take care to protect characters in
# MSVCGEN_BUILD_ROOT which have special meaning to 'sed'.  For instance, in
# MSVCGEN_BUILD_ROOT, if $(TOP)/ is "./", then we want it to match a literal
# period followed by a slash, not 'any character' followed by a slash, so it
# must be transformed to "\./". (Presently we take the simple-minded approach
# of protecting only "." since it arises frequently.)
MSVCGEN_SED_PROTECT = "$(SED) 's:\\.:\\\\\\.:g'" ;

MSVC_VERSION ?= 7 ;
if $(MSVC_VERSION) = 6
{
  SUFPRJ = dsp ;
  SUFWSP = dsw ;
  MSVC_FORCE_CRLF = yes ;
  MSVC_TEMPLATE_SUFFIX = 6 ;
}
else if $(MSVC_VERSION) = 10 # Version 10
{
  SUFPRJ = vcxproj ;
  SUFWSP = sln ;
  MSVC_FORCE_CRLF = no ;
  MSVC_TEMPLATE_SUFFIX = 10 ;
  MSVC_FORMATVERSION_WSP = 11.00 ;
  MSVC_WSP_HEADERCOMMENT = "# Visual C++ Express 2010" ;
}
else # Versions 7, 71, 8, 9 and "unknown"
{
  SUFPRJ = vcproj ;
  SUFWSP = sln ;
  MSVC_FORCE_CRLF = no ;
  MSVC_TEMPLATE_SUFFIX = 7 ;
  if $(MSVC_VERSION) = 7
  {
    MSVC_FORMATVERSION_PRJ = 7.00 ;
    MSVC_FORMATVERSION_WSP = 7.00 ;
  }
  else if $(MSVC_VERSION) = 71
  {
    MSVC_FORMATVERSION_PRJ = 7.10 ;
    MSVC_FORMATVERSION_WSP = 8.00 ;
  }
  else if $(MSVC_VERSION) = 8
  {
    MSVC_FORMATVERSION_PRJ = 8.00 ;
    MSVC_FORMATVERSION_WSP = 9.00 ;
    MSVC_WSP_HEADERCOMMENT = "# Visual C++ Express 2005" ;
  }
  else if $(MSVC_VERSION) = 9
  {
    MSVC_FORMATVERSION_PRJ = 9.00 ;
    MSVC_FORMATVERSION_WSP = 10.00 ;
    MSVC_WSP_HEADERCOMMENT = "# Visual C++ Express 2008" ;
  }
  else
  {
    exit "No msvcgen support for MSVC version $(MSVC_VERSION) yet!" ;
  }
}
  
MSVC.TSUFPRJ = tproj ;
MSVC.TSUFWKP = twks ;

MSVC.DEPEND ?= ;
MSVC.DEPEND_DEBUG ?= ;
MSVC.LIBRARY ?= ;
MSVC.LIBRARY_DEBUG ?= ;
MSVC.LFLAGS ?= ;
MSVC.LFLAGS_DEBUG ?= ;
MSVC.LIBRARY_DELAY ?= ;
MSVC.CFLAGS ?= ;
MSVC.CFLAGS_DEBUG ?= ;
MSVC.DEFINES ?= ;
MSVC.DEFINES_DEBUG ?= ;

# Set up default project types
rule MsvcRegisterType
{
  local type = $(1) ;
  local prefix = $(2) ;
  
  MSVC.DEPEND.$(type) ?= ;
  MSVC.DEPEND_DEBUG.$(type) ?= ;
  MSVC.LIBRARY.$(type) ?= ;
  MSVC.LIBRARY_DEBUG.$(type) ?= ;
  MSVC.LFLAGS.$(type) ?= ;
  MSVC.LFLAGS_DEBUG.$(type) ?= ;
  MSVC.CFLAGS.$(type) ?= ;
  MSVC.CFLAGS_DEBUG.$(type) ?= ;
  MSVC.DEFINES.$(type) ?= ;
  MSVC.DEFINES_DEBUG.$(type) ?= ;
  
  MSVC.PREFIX.$(type) = $(prefix) ;
}

MsvcRegisterType appgui : app ;
MsvcRegisterType appcon : app ;
MsvcRegisterType plugin : plg ;
MsvcRegisterType library_static : lib ;
MsvcRegisterType library_shared : lib ;
MsvcRegisterType dll : dll ;
MsvcRegisterType group : grp ;
MsvcRegisterType workspace : wks ;

# Set/get per-type properties.
rule MsvcGetTypeProp1
{
  local type = $(1) ;
  local prop = $(2) ;
  return $(MSVC.PROP.TYPE.$(type).$(prop)) ;
}

rule MsvcSetTypeProp1
{
  local type = $(1) ;
  local prop = $(2) ;
  local value = $(3) ;
  local options = $(4) ;
  if ! [ IsElem $(options) : weak ] || ! $(MSVC.PROP.TYPE.$(type).$(prop))
  {
    MSVC.PROP.TYPE.$(type).$(prop) = $(value) ;
  }
}

# Set/get per-target props. Also inherits props from the type.
rule MsvcGetTargetProp1
{
  local target = $(1) ;
  local prop = $(2) ;
  local value ;
  if $(MSVC.PROP.TARGET.$(target).$(prop).SET)
  {
    value = $(MSVC.PROP.TARGET.$(target).$(prop)) ;
  }
  else
  {
    value = [ MsvcGetTypeProp $($(target)_TYPE) : $(prop) ] ;
  }
  return $(value) ;
}

rule MsvcSetTargetProp1
{
  local target = $(1) ;
  local prop = $(2) ;
  local value = $(3) ;
  local options = $(4) ;
  if ! [ IsElem $(options) : weak ] || ! $(MSVC.PROP.TARGET.$(target).$(prop))
  {
    MSVC.PROP.TARGET.$(target).$(prop) = $(value) ;
    MSVC.PROP.TARGET.$(target).$(prop).SET = true ;
  }
}

# Set up default use/generation of resources, manifests and version info.
MsvcSetTypeProp appgui : resources : yes ;
MsvcSetTypeProp appcon : resources : yes ;
MsvcSetTypeProp plugin : resources : yes ;
MsvcSetTypeProp library_shared : resources : yes ;
MsvcSetTypeProp dll : resources : yes ;
MsvcSetTypeProp appgui : rsrcManifest : yes ;
MsvcSetTypeProp appcon : rsrcManifest : yes ;
MsvcSetTypeProp plugin : rsrcMetadata : yes ;
MsvcSetTypeProp appgui : rsrcVersion : yes ;
MsvcSetTypeProp appcon : rsrcVersion : yes ;
MsvcSetTypeProp plugin : rsrcVersion : yes ;
MsvcSetTypeProp library_shared : rsrcVersion : yes ;
MsvcSetTypeProp dll : rsrcVersion : yes ;

rule MsvcRegisterVariableProp1
{
  local variable = $(1) ;
  local prop = $(2) ;
  MSVCGEN_VARIABLES_FROM_PROPS += $(variable) $(prop) ;
}

SetProperty build : projgen : msvc ;
SetProperty build : projgen_version : $(MSVC_VERSION) ;

# MsvcAddPrefix name : type
rule MsvcAddPrefix
{
  local name = $(1) ;
  local type = $(2) ;
  local prefix = $(MSVC.PREFIX.$(type)) ;
  if $(prefix) { name = "$(prefix)$(name)" ; }
  return $(name) ;
}

#----------------------------------------------------------------------------
# Override some rules

actions GenerateWin32ManifestRc
{
    cat > $(<) << __EOF__
// This file is generated automatically.

#if !defined(PROJECTGEN_VERSION) || (PROJECTGEN_VERSION < 8)
1 24 "$(MANIFEST_NAME)"
#endif
__EOF__
}

rule IconsMakeWin32ICO { }

## MsvcGenConfig variable [ : value ]
##   (See documentation above.)
rule MsvcGenConfig1
{
  $(<) = $(>) ;
}

## MsvcGenVariable variable [ : value ]
##   (See documentation above.)
rule MsvcGenVariable1
{
  MSVCGEN_VARIABLES += "$(<)|$(>)" ;
}

## MsvcGenWorkspace name [ : accepts [ : rejects ]]
##   (See documentation above.)
rule MsvcGenWorkspace1
{
  local name = $(1) ;
  local accepts = $(2) ;
  local rejects = $(3) ;
  local builddir = [ msvcgen_build_dir $(MSVC_VERSION) ] ;
  local workdir = [ msvcgen_work_dir $(MSVC_VERSION) ] ;
  local wksname = $(MSVC.NAME_OVERRIDE.$(name)) ;
  if ! $(wksname) { wksname = [ MsvcAddPrefix $(name) : workspace ] ; }

  MSVC.WORKSPACES += $(name) ;

  local respdir = $(workdir) ;
  local respfile = $(wksname:G=msvcresp:S=.resp) ;
  Always $(respfile) ;
  $(name)_WKS_RESPFILE = $(respfile) ;
  $(name)_WKS_RESPDIR = $(respdir) ;

  # Boilerplate.
  ResponseFile $(respfile) :
    "key|value"
    "accept|$(accepts)"
    "reject|$(rejects)"
    "formatversion|$(MSVC_FORMATVERSION_WSP)"
    "headercomment|$(MSVC_WSP_HEADERCOMMENT)"
    "projectext|$(SUFPRJ)"
    "msvcversion|$(MSVC_VERSION)"
    $(MSVCGEN_VARIABLES)
    : notfile : $(respdir) ;
  MsvcRmTemps msvcgen : $(respfile) ;

  local buildfile = $(wksname:G=msvcworkspace:S=.$(MSVC.TSUFWKP)) ;
  Always $(buildfile) ;
  MakeLocate $(buildfile) : $(builddir) ;
  Includes $(buildfile) : $(respfile) ;
  MSVC_BUILD_TYPE on $(buildfile) = workspace ;
  MsvcBuildFile $(buildfile) : $(respfile) ;
  Depends msvcgenrun : $(buildfile) ;
  MsvcRmTemps msvcgen : $(buildfile) ;
}

## MsvcGenSubDir dircomponents [ : version ]
##   (See documentation above.)
rule MsvcGenSubDir1
{
  local path = $(1) ;
  local version = $(2) ;

  local relpath ;
  if ! $(path[2])
  {
    relpath = $(DOT) ;
  }
  else
  {
    local i ;
    for i in $(path[2-])
    {
      relpath += $(DOTDOT) ;
    }
  }

  SetProperty msvcgen : outdir$(version) : [ msvcgen_target_dir $(path) ] ;
  SetProperty msvcgen : relpath$(version) : $(relpath) ;

  MSVCGEN_OUTDIR_$(version) = [ Property msvcgen : outdir$(version) ] ;
}

## MsvcGenTemplateDir dircomponents
##   (See documentation above.)
rule MsvcGenTemplateDir1
{
  SetProperty msvcgen : templatedir : [ msvcgen_template_dir $(<) ] ;

  MSVCGEN_TEMPLATEDIR = [ Property msvcgen : templatedir ] ;
}

## MsvcGenName target : name
##   (See documentation above.)
rule MsvcGenName1
{
  MSVC.NAME_OVERRIDE.$(<) = $(>) ;
}

## MsvcAddFileToRespFile respfile : files : respdir ;
rule MsvcAddFileToProject
{
  local respfile = $(1) ;
  local files = $(2) ;
  local respdir = $(3) ;
  
  for f in $(files)
  {
    local file_base = $(f:G=:D=) ;
    if [ IsElem $(file_base) : $($(respfile)_FILES) ]
    {
      ResponseFile $(respfile) : "file_obj_unique|$(f)" : notfile : $(respdir) ;
    }
    else
    {
      ResponseFile $(respfile) : "file|$(f)" : notfile : $(respdir) ;
      $(respfile)_FILES += $(file_base) ;
    }
  }
}

## MsvcProject target : type : sources : options
##   Create a project file for 'target', which is the project's raw name.
##   'sources' is a list of files comprising the target.
##   The output file of the project (library, executable etc) is controlled by
##   the 'outputfile' property.
rule MsvcProject
{
  local rawname = $(1) ;
  local type = $(2) ;
  local decorated = [ MsvcGetTargetProp $(rawname) : outputfile ] ;
  local sources = $(3) ;
  local options = $(4) ;
  local relpath = [ Property msvcgen : relpath$(MSVC_VERSION) ] ;
  local relpathcommon = [ Property msvcgen : relpathcommon ] ;
  if "$(relpathcommon)" = ""
  {
    relpathcommon = $(relpath) ;
  }
  local outdir = [ Property msvcgen : outdir$(MSVC_VERSION) ] ;
  local outdircommon = [ Property msvcgen : outdircommon ] ;
  if "$(outdircommon)" = ""
  {
    outdircommon = $(outdir) ;
  }
  local builddir = [ msvcgen_build_dir $(MSVC_VERSION) ] ;
  local workdir = [ msvcgen_work_dir $(MSVC_VERSION) ] ;
  local workdircommon = [ msvcgen_work_dir common ] ;

  local msvcname = $(MSVC.NAME_OVERRIDE.$(rawname)) ;
  if ! $(msvcname) { msvcname = [ MsvcAddPrefix $(rawname) : $(type) ] ; }
  $(rawname)_MSVCNAME = $(msvcname) ;
      
  local respdir = $(workdir) ;
  local respfile = $(msvcname:G=msvcresp:S=.resp) ;
  Always $(respfile) ;
  $(rawname)_PRJ_RESPFILE = $(respfile) ;
  $(rawname)_PRJ_RESPDIR = $(respdir) ;
  
  local extravars = [ MsvcGetTargetProp $(rawname) : linkerextra ] ;
  {
    local vars_from_props = $(MSVCGEN_VARIABLES_FROM_PROPS) ;
    while $(vars_from_props)
    {
      local var = $(vars_from_props[1]) ;
      local prop = $(vars_from_props[2]) ;
      local value = [ MsvcGetTargetProp $(rawname) : $(prop) ] ;
      
      extravars += "$(var)|$(value)" ;
      
      vars_from_props = $(vars_from_props[3-]) ;
    }
  }
  
  # Boilerplate.
  ResponseFile $(respfile) :
    "key|value"
    "formatversion|$(MSVC_FORMATVERSION_PRJ)"
    "packageversion|$(PACKAGE_VERSION_LIST[1]).$(PACKAGE_VERSION_LIST[2])"
    "projtype|$(type)"
    "project|$(msvcname)"
    "rawtarget|$(rawname)"
    "target|$(decorated)"
    "sourceroot|$(relpath:J=/)"
    "buildroot|$(relpath:J=/)"
    "subdir|$(SUBDIR)"
    "striproot|$(MSVCGEN_STRIP_ROOT)"
    "define|$(MSVC.DEFINES)"
    "define|$(MSVC.DEFINES.$(type))"
    "definedebug|$(MSVC.DEFINES_DEBUG)"
    "definedebug|$(MSVC.DEFINES_DEBUG.$(type))"
    "cflags|$(MSVC.CFLAGS)"
    "cflags|$(MSVC.CFLAGS.$(type))"
    "cflagsdebug|$(MSVC.CFLAGS_DEBUG)"
    "cflagsdebug|$(MSVC.CFLAGS_DEBUG.$(type))"
    "lflags|$(MSVC.LFLAGS)"
    "lflags|$(MSVC.LFLAGS.$(type))"
    "lflagsdebug|$(MSVC.LFLAGS_DEBUG)"
    "lflagsdebug|$(MSVC.LFLAGS_DEBUG.$(type))"
    "library|$(MSVC.LIBRARY)"
    "library|$(MSVC.LIBRARY.$(type))"
    "librarydebug|$(MSVC.LIBRARY_DEBUG)"
    "librarydebug|$(MSVC.LIBRARY_DEBUG.$(type))"
    "librarydelay|$(MSVC.LIBRARY_DELAY)"
    "librarydelay|$(MSVC.LIBRARY_DELAY.$(type))"
    "msvcversion|$(MSVC_VERSION)"
    "static|$($(rawname)_STATIC)"
    $(MSVCGEN_VARIABLES)
    $(extravars)
    : notfile : $(respdir) ;
  MsvcRmTemps msvcgen : $(respfile) ;
  
  # Only include source and headers files for now.  In the future, we also
  # want to include .cfg files and any other textual resources which which the
  # user might care to read/view in the MSVC IDE.
  local i ;
  for i in $(sources)
  {
    if [ IsElem $(i:S) : .h .hpp .hxx .H .c .cc .cpp .cxx .C .m .mm .M ]
    {
      local fileinproj ;
      if $($(rawname)_STATIC) = "yes"
      {
	fileinproj = $(i) ;
      }
      else
      {
	fileinproj = $(i:R=$(SEARCH_SOURCE)) ;
      }
      MsvcAddFileToProject $(respfile) : $(fileinproj) : $(respdir) ;
    }
  }
  for i in $($(rawname)_EXTRASOURCES)
  {
    ResponseFile $(respfile) : "file|$(i)" : notfile : $(respdir) ;
  }

  # Add resource file.
  if [ MsvcGetTargetProp $(rawname) : resources ] = "yes"
  {
    local resource = $(msvcname:S=.rc) ;
    Depends msvcgen : $(resource) ;
    MakeLocate $(resource) : $(outdircommon) ;
    SEARCH on $(resource) = $(outdircommon) ;
    NAME on $(resource) = $(rawname) ;
    $(rawname)_RCNAME = $(resource) ;
    MsvcAddFileToProject $(respfile) : $(resource:R=$(outdircommon)) : $(respdir) ;
  
    if [ MsvcGetTargetProp $(rawname) : rsrcVersion ] = "yes"
    {
      local versionrc = $(resource:S=.vrctmp) ;
      MakeLocate $(versionrc) : $(workdircommon) ;
      MakeVersionRc $(versionrc) : $(rawname) ;
      Depends $(versionrc) : $(TOP)/Jamconfig ;
      Depends $(versionrc) : $(SUBDIR)/Jamfile ;
      Win32Resource $(rawname) : $(versionrc) ;
      MsvcRmTemps $(resource) : $(versionrc) ;
    }
    
    if [ MsvcGetTargetProp $(rawname) : rsrcMetadata ] = "yes"
    {
      local metarc = $(resource:S=.mrctmp) ;
      MakeLocate $(metarc) : $(workdircommon) ;
      SEARCH on $(metarc) = $(SEARCH_SOURCE) ;
      Depends $(metarc) : $($(rawname)_METAFILE) ;
      GenerateWin32MetadataRc $(metarc) : $($(rawname)_METAFILE) ;
      
      Win32Resource $(rawname) : $(metarc) ;
      MsvcRmTemps $(resource) : $(metarc) ;
      MsvcAddFileToProject $(respfile) :
	$($(rawname)_METAFILE:R=$(SEARCH_SOURCE)) : $(respdir) ;
    }

    if [ MsvcGetTargetProp $(rawname) : rsrcManifest ] = "yes"
    {
      if ! [ IsElem nomanifest : $(options) ]
      {
        local manifest = $(msvcname:S=.manifest) ; 
        MakeLocate $(manifest) : $(outdircommon) ;
        MakeManifestFile $(manifest) : $(rawname) ;
        Depends $(manifest) : $(TOP)/Jamconfig ;
        Depends $(manifest) : $(SUBDIR)/Jamfile ;
        Depends msvcgen : $(manifest) ;
      
        local manifest_amd64 = $(msvcname:S=)-x64.manifest ; 
        MakeLocate $(manifest_amd64) : $(outdircommon) ;
        MakeManifestFile $(manifest_amd64) : $(rawname) : amd64 ;
        Depends $(manifest_amd64) : $(TOP)/Jamconfig ;
        Depends $(manifest_amd64) : $(SUBDIR)/Jamfile ;
        Depends msvcgen : $(manifest_amd64) ;
      
        local manifestrc = $(resource:S=.mfrctmp) ;
        MakeLocate $(manifestrc) : $(workdircommon) ;
        MANIFEST_NAME on $(manifestrc) = $(manifest) ;
        GenerateWin32ManifestRc $(manifestrc) ;
        Depends $(manifestrc) : $(manifest) ;
  
	ResponseFile $(respfile) : "manifest|$(manifest:R=$(outdircommon))" : notfile : $(respdir) ;
	ResponseFile $(respfile) : "manifest-x64|$(manifest_amd64:R=$(outdircommon))" : notfile : $(respdir) ;
      
        Win32Resource $(rawname) : $(manifestrc) ;
        MsvcRmTemps $(resource) : $(manifestrc) ;
      }
      
      local icon = [ ApplicationIcon win32 : $(rawname) ] ;
      if ! $(icon)
      {
        local apptype = gui ;
        if $(type) = "appcon" { apptype = console ; }
        icon = [ ApplicationIconDefault win32 : $(apptype) ] ;
      }
      if $(icon)
      {
	local iconrc = $(resource:S=.iconrctmp) ;
	# RELPATH includes trailing slash (hence the "" in ConcatDirs).
	RELPATH on $(iconrc) = [ ConcatDirs $(relpathcommon) "" ] ;
	MakeLocate $(iconrc) : $(workdircommon) ;
	Depends $(iconrc) : $(icon) ;
        Depends $(iconrc) : $(SUBDIR)/Jamfile ;
        GenerateIconRc $(iconrc) : $(icon) ;
	Win32Resource $(rawname) : $(iconrc) ;
	MsvcRmTemps $(resource) : $(iconrc) ;
      }
    }
  }

  ResponseFile $(respfile) : $(MSVC.RESPEMIT.GLOBAL) : notfile : $(respdir) ;
  
  local inckeys = "include" includedebug ;
  local incdirs = $(MSVC.INCDIRS_LITERAL) ;
  ResponseFile $(respfile) : "$(inckeys)|$(incdirs)" : notfile : $(respdir) ;
  ResponseFile $(respfile) : "$(inckeys)-x64|$(incdirs)" : notfile : $(respdir) ;
  
  local incdir ;
  for incdir in $(MSVC.INCDIRS)
  {
    if $(incdir) = "."
    {
      incdir = [ ConcatDirs $(relpath) ] ;
    }
    else
    {
      incdir = [ ConcatDirs $(relpath) $(incdir) ] ;
    }
    ResponseFile $(respfile) : "$(inckeys)|$(incdir)" : notfile : $(respdir) ;
    ResponseFile $(respfile) : "$(inckeys)-x64|$(incdir)" : notfile : $(respdir) ;
  }
  
  # Per-project include dirs are handled in the IncludeDir rule

  if ! [ Property msvcgen : templatedir ]
  {
    exit "Error: You must invoke MsvcGenTemplateDir for project generation." ;
  }

  local buildfile = $(msvcname:G=msvcproject:S=.$(MSVC.TSUFPRJ)) ;
  Always $(buildfile) ;
  MakeLocate $(buildfile) : $(builddir) ;
  Includes $(buildfile) : $(respfile) ;
  MSVC_BUILD_TYPE on $(buildfile) = project ;
  MsvcBuildFile $(buildfile) : $(respfile) ;
  Depends msvcgenrun : $(buildfile) ;
  MsvcRmTemps msvcgen : $(buildfile) ;

  if ! $(MSVC.WORKSPACES)
  {
    exit "You must specify at least one workspace via MsvcGenWorkspace" ;
  }

  local w ;
  for w in $(MSVC.WORKSPACES)
  {
    ResponseFile $($(w)_WKS_RESPFILE) : "project|$(msvcname)" : notfile :
      $($(w)_WKS_RESPDIR) ;
  }

  Clean msvcclean : $(target) ;
}

#----------------------------------------------------------------------------

# Ensure that the pseudo-groups exist with which the overridden Application,
# Plugin, and Library rules will register their targets. We have to do this
# here rather than at the top-level (outside of any rule invocation) because we
# need to give the client time to invoke MsvcGenWorkspace first to set up the
# workspaces into which these groups will be inserted. If we tried registering
# theses pseudo-groups at the top-level, registration would occur before the
# client has had a chance to invoke MsvcGenWorkspace, thus these pseudo-groups
# would not inhabit any workspaces.
rule RegisterWellKnownCompileGroup1
{
  local group = $(1) ;
  if $(MSVCGEN.WELL_KNOWN_GROUP_REGISTERED.$(group)) != yes
  {
    MSVCGEN.WELL_KNOWN_GROUP_REGISTERED.$(group) = yes ;
    RegisterCompileGroups $(group) ;
  }
}

rule RegisterWellKnownCompileGroup
{
  RegisterWellKnownCompileGroup1 all ;
  if "$(1)" != ""
  {
    RegisterWellKnownCompileGroup1 $(1) ;
  }
  local g ;
  for g in $(MSVCGEN.DELAYED_COMPILE_GROUPS)
  {
    RegisterWellKnownCompileGroup1 $(g) ;
  }
  MSVCGEN.DELAYED_COMPILE_GROUPS = ;
}

rule _ApplyStaticPluginFlags
{
  local package target plugins ;
  plugins = $(2) ;
  package = $(3) ;
  
  if $(package)
  {
    # External static plugins.
    local lflags.debug lflags.release p mode arch ;
    # Grab flags
    local target_lflags.release.x86 target_lflags.debug.x86 ;
    local target_lflags.release.x64 target_lflags.debug.x64 ;
    local target_relaydeps ;
    for p in $(plugins)
    {
      NotFile $(p) ;
      for mode in debug release
      {
	for arch in x86 x64
	{
	  local cflags ;
	  if $(STATICPLUGIN.$(p).CFLAGS.$(mode).$(arch).$(MSVC_VERSION))
	  {
	    cflags = $(STATICPLUGIN.$(p).CFLAGS.$(mode).$(arch).$(MSVC_VERSION)) ;
	  }
	  else if $(STATICPLUGIN.$(p).CFLAGS.$(mode).$(MSVC_VERSION))
	  {
	    cflags = $(STATICPLUGIN.$(p).CFLAGS.$(mode).$(MSVC_VERSION)) ;
	  }
	  else
	  {
	    cflags = $(STATICPLUGIN.$(p).CFLAGS.$(mode)) ;
	  }
	  if $(STATICPLUGIN.$(p).LFLAGS.$(mode).$(arch).$(MSVC_VERSION))
	  {
	    target_lflags.$(mode).$(arch) += $(STATICPLUGIN.$(p).LFLAGS.$(mode).$(arch).$(MSVC_VERSION)) ;
	  }
	  else if $(STATICPLUGIN.$(p).LFLAGS.$(mode).$(MSVC_VERSION))
	  {
	    target_lflags.$(mode).$(arch) += $(STATICPLUGIN.$(p).LFLAGS.$(mode).$(MSVC_VERSION)) ;
	  }
	  else
	  {
	    target_lflags.$(mode).$(arch) += $(STATICPLUGIN.$(p).LFLAGS.$(mode)) ;
	  }
	  for target in $(1)
	  {
	    MsvcCFlags $(target) : $(cflags) : $(arch) ;
	  }
	}
      }
      
      local relaydeps = $(STATICPLUGIN.$(p).RELAYDEPS) ;
      for relaydep in $(relaydeps)
      {
	local has_dep = no ;
	for trd in $(target_relaydeps)
	{
	  if $(trd) = $(relaydep)
	  {
	    has_dep = yes ;
	  }
	}
	if $(has_dep) = no
	{
          target_relaydeps += $(relaydep) ;
          for target in $(1)
          {
            RelayLibs $(target) : $(relaydep) : $(STATICPLUGIN.$(p).RELAYLIBS.$(relaydep)) ;
          }
	}
      }
    }
    for mode in debug release
    {
      for arch in x86 x64
      {
	local lflags = [ RemoveDupFlags $(target_lflags.$(mode).$(arch)) ] ;
	for target in $(1)
	{
	  MsvcLFlags $(target) : $(lflags) : $(mode) : $(arch) ;
	}
      }
    }
  }
  else
  {
    # link with static plugins
    for target in $(1)
    {
      LinkWith $(target) : $(STATICPLUGINS.LIBRARY) ;
    }
    
    # Local static plugins
    local libs p ;
    # Grab flags
    local target_relaydeps ;
    for p in $(plugins)
    {
      for target in $(1)
      {
        LinkWith $(target) : $($(p).NEEDLIBS) ;
        ExternalLibs $(target) : $($(p).EXTERNALLIBS) ;
      }

      for mode in debug release
      {
	for a in x86 x64
	{
          for target in $(1)
          {
            MsvcExternalLibrary $(target) : $($(p)_$(mode)_$(a)_EXTERNALLIBS) : $(mode) : $(a) ;
          }
	}
      }
      
      local relaydeps = $($(p).RELAYDEPS) ;
      for relaydep in $(relaydeps)
      {
	local has_dep = no ;
	for trd in $(target_relaydeps)
	{
	  if $(trd) = $(relaydep)
	  {
	    has_dep = yes ;
	  }
	}
	if $(has_dep) = no
	{
          target_relaydeps += $(relaydep) ;
          for target in $(1)
          {
            RelayLibs $(target) : $(relaydep) : $(STATICPLUGIN.$(p).RELAYLIBS.$(relaydep)) ;
          }
	}
      }
    }
  }
  
}

rule LinkStaticPlugins
{
  local package target plugins optplugins ;
  # Fetch the parameters
  target = $(1) ;
  plugins = $(2) ;
  optplugins = $(3) ;
  package = $(4) ;
  
  if $(package)
  {
    # External static plugins.
    # First include static plugin info
    if ! $(HAVE_STATICDEPS.$(package))
    {
      include $($(package).STATICDEPS) ;
      HAVE_STATICDEPS.$(package) = yes ;
    }
    local lflags.debug lflags.release p mode ;
    # Collect optional plugins
    for p in $(optplugins)
    {
      if [ IsElem $(p) : $(STATICPLUGINS.AVAILABLE) ]
      {
	plugins += $(p) ;
      }
    }
  }
  else
  {
    # Local static plugins
    local p ;
    # Collect optional plugins
    for p in $(optplugins)
    {
      if $($(p)_TYPE)
      {
	plugins += $(p) ;
      }
    }
  }
  
  # Generate static plugin instantiation
  local outdir = [ Property msvcgen : outdircommon ] ;
  if "$(outdir)" = ""
  {
    outdir = [ Property msvcgen : outdir$(MSVC_VERSION) ] ;
  }
  # @@@ Prefix hardcoded
  local extrafiles_prefix = $(MSVC.PREFIX.appgui)$(<) ;
  local staticuse_out ;
  local tag ;
  if $(package)
  {
    staticuse_out = $(extrafiles_prefix)_staticuse_$(package).cpp ; 
    tag = "_static_use_$(package)" ;
  }
  else
  {
    staticuse_out = $(extrafiles_prefix)_staticuse.cpp ;
    tag = "_static_use" ;
  }
  
  MakeLocate $(staticuse_out) : $(outdir) ;
  SEARCH on $(staticuse_out) = $(outdir) ;
  
  GenerateStaticPluginInstantiation $(staticuse_out) : $(plugins) : $(tag) ;
  Depends msvcgen : $(staticuse_out) ;

  # Build a shared lib containing the static plugins.
  # This is done to be more LGPL-friendly.
  if ( $(TRUE_STATIC_PLUGINS) != "yes" )
  {
    local plugin_lib_name appglue libglue ;
    if $(package)
    {
      plugin_lib_name = $(target)_plugins_$(package) ;
    }
    else
    {
      plugin_lib_name = $(target)_plugins ;
    }
    
    # prepare source files
    if $(package)
    {
      libglue = $(extrafiles_prefix)_static_glue_lib_$(package).cpp ;
    }
    else
    {
      libglue = $(extrafiles_prefix)_static_glue_lib.cpp ;
    }
  
    MakeLocate $(libglue) : $(outdir) ;
    SEARCH on $(libglue) = $(outdir) ;
    
    GeneratePluginLibraryGlueLib $(libglue) : $(plugin_lib_name) : $(tag) ;
    
    Library $(plugin_lib_name) : : noinstall notest independent nohelp shared ;
    MsvcAddFileToProject $($(plugin_lib_name)_PRJ_RESPFILE) : 
      $(libglue:R=$(outdir)) : $($(target)_PRJ_RESPDIR) ;
    MsvcAddFileToProject $($(plugin_lib_name)_PRJ_RESPFILE) : 
      $(staticuse_out:R=$(outdir)) : $($(target)_PRJ_RESPDIR) ;
    LibDepends $(plugin_lib_name) : $(target_link_with) ;
    LFlags $(plugin_lib_name) : $(target_lflags) ;
    Depends msvcgen : $(libglue) ;
    
    # prepare source files
    if $(package)
    {
      appglue = $(extrafiles_prefix)_static_glue_app_$(package).cpp ;
    }
    else
    {
      appglue = $(extrafiles_prefix)_static_glue_app.cpp ;
    }
  
    MakeLocate $(appglue) : $(outdir) ;
    SEARCH on $(appglue) = $(outdir) ;
    
    GeneratePluginLibraryGlueApp $(appglue) : $(plugin_lib_name) ;
    
    # We need to get the external libs for the plugin lib; but they have to be 
    # specified after LinkStaticPlugins
    $(target).PROPAGATE_EXTERNALLIBS += $(plugin_lib_name) ;
    
    # Add usefile to project
    MsvcAddFileToProject $($(target)_PRJ_RESPFILE) : 
      $(appglue:R=$(outdir)) : $($(target)_PRJ_RESPDIR) ;
    Depends $(target) : $(appglue) ;
    Depends msvcgen : $(appglue) ;
    LinkWith $(target) : $(plugin_lib_name) ;
    
    # @@@ Something is overflowing Jam's little mind or so ...
    # $(target) changes it's value, somewhere!
    _ApplyStaticPluginFlags $(<) $(plugin_lib_name) : $(plugins) : $(package) ;
  }
  else
  {
    _ApplyStaticPluginFlags $(target) : $(plugins) : $(package) ;
    
    # Add usefile to project
    MsvcAddFileToProject $($(target)_PRJ_RESPFILE) : 
      $(staticuse_out:R=$(outdir)) : $($(target)_PRJ_RESPDIR) ;
    Depends $(target) : $(staticuse_out) ;
  }
}

rule Application
{
  RegisterWellKnownCompileGroup apps ;

  local projtype ;
  if [ IsElem console : $(3) ]
  {
    projtype = appcon ;
  }
  else
  {
    projtype = appgui ;
  }
  $(<)_TYPE = $(projtype) ;
  MsvcSetTargetProp $(<) : outputfile : $(<:S=.exe) : weak ;
  MsvcProject $(<) : $(projtype) : $(>) : $(3) ;
  
  CompileGroups $(<) : all apps ;
}

rule Plugin
{
  RegisterWellKnownCompileGroup plugins ;

  $(<)_TYPE = plugin ;
  
  local outdir = [ Property msvcgen : outdir$(MSVC_VERSION) ] ;
  local outdircommon = [ Property msvcgen : outdircommon ] ;
  if "$(outdircommon)" = ""
  {
    outdircommon = $(outdir) ;
  }
  local plugin_impl_file = plugin_impl.cpp ;
  MakeLocate $(plugin_impl_file) : $(outdircommon) ;
  WritePluginImplement $(plugin_impl_file) ;
  Depends msvcgen : $(plugin_impl_file) ;
  $(<)_EXTRASOURCES = $(plugin_impl_file:R=$(outdircommon)) ;
  
  local metafile ;
  metafile = [ FAppendSuffix $(<) : $(SUFMETA) ] ;
  SEARCH on $(metafile) = $(SEARCH_SOURCE) ;
  $(<)_METAFILE = $(metafile) ;
  MsvcSetTargetProp $(<) : outputfile : $(<:S=$(MSVCGEN.PLUGIN_EXT.$(<):E=.dll)) : weak ;
  MsvcProject $(<) : plugin : $(>) ;
  CompileGroups $(<) : all plugins ;

  STATICPLUGINS.SOURCES.$(<) += $(>:R=$(SEARCH_SOURCE)) ;
  STATICPLUGINS.SUBTARGETS += $(<) ;

  # Generate static variant of plugin
  #  Static registry
  local outdir = [ Property msvcgen : outdircommon ] ;
  local staticreg_out = $(MSVC.PREFIX.library_static)$(<)_staticreg.cpp ;
  MakeLocate $(staticreg_out) : $(outdir) ;
  SEARCH on $(staticreg_out) = $(outdir) ;
  GenerateStaticPluginRegistration $(staticreg_out) : $(metafile) ;
  Depends msvcgen : $(staticreg_out) ;
  STATICPLUGINS.SOURCES.$(<) += $(outdir)/$(staticreg_out) ;
}

rule Library
{
  local options = $(3) ;

  RegisterWellKnownCompileGroup libs ;
  local type decorated ;
  
  if [ IsElem shared : $(3) ]
  {
    type = library_shared ;
    decorated = $(<:S=.dll) ;
    MsvcSetTargetProp $(<) : importlib : $(<:S=.lib) : weak ;
  }
  else
  {
    type = library_static ;
    decorated = $(<:S=.lib) ;
  }
  $(<)_TYPE = $(type) ;
  MsvcSetTargetProp $(<) : outputfile : $(decorated) : weak ;
  MsvcProject $(<) : $(type) : $(>) ;
  if ! [ IsElem independent : $(options) ]
  {
    CompileGroups $(<) : all libs ;
  }
}

rule DLL
{
  RegisterWellKnownCompileGroup ;
  
  $(<)_TYPE = dll ;
  MsvcSetTargetProp $(<) : outputfile : $(3:E=$(<:S=.dll)) : weak ;
  MsvcProject $(<) : dll : $(>) ;
  CompileGroups $(<) : all ;
}

rule StaticPluginLibrary
{
  local name = $(<) ;
  local rejects = $(>) ;
  local t ;

  local targets = $(STATICPLUGINS.SUBTARGETS) ;
  if $(rejects)
  {
    targets = [ Filter $(targets) : $(rejects) ] ;
  }
  local sources extlibs ;
  for t in $(targets)
  {
    sources += $(STATICPLUGINS.SOURCES.$(t)) ;
    extlibs += $($(t).EXTERNALLIBS) ;
  }

  $(name)_STATIC = "yes" ;
  # Set up library
  Library $(name) : $(sources) ;
  MsvcDefine $(name) : CS_STATIC_LINKED ;
  # We need the CFLAGS of external dependencies, but not the LFLAGS.
  local extlib ;
  for extlib in [ RemoveDups $(extlibs) ]
  {
    _ExternalLibsHelperMsvc $(name) : $(extlib) : MsvcCFlags : CFLAGS ;
    _ExternalLibsHelperMsvc $(name) : $(extlib) : _MsvcDefine  : DEFINES ;
    _ExternalLibsHelperMsvc $(name) : $(extlib) : _MsvcIncDirs : INCDIRS ;
  }

  # Write out needed CFLAGS, LFLAGS
  local outdir = [ Property msvcgen : outdircommon ] ;
  if $(outdir) = ""
  {
    outdir = [ Property msvcgen : outdir$(MSVC_VERSION) ] ;
  }
  STATICPLUGINS.DEPENDENCIES = $(name)_msvc$(MSVC_VERSION).jam ;
  MakeLocate $(STATICPLUGINS.DEPENDENCIES) : $(outdir) ;
  SEARCH on $(STATICPLUGINS.DEPENDENCIES) = $(outdir) ;
  for t in $(targets)
  {
    NotFile $(t) ;
    WriteDependencies $(STATICPLUGINS.DEPENDENCIES) : $(t) : $(name) ;
  }
  Always $(STATICPLUGINS.DEPENDENCIES) ;
  Depends msvcgen : $(STATICPLUGINS.DEPENDENCIES) ;
  
  STATICPLUGINS.LIBRARY = $(name) ;
  # Enable compiler-provided multithreading.
  # This makes sense here since static plugin libs are typically
  # very low in the dependency hierarchy.
  MsvcParallelCompile $(name) ;
}

# Write out CFLAGS, LFLAGS needed by a plugin
rule WriteDependencies
{
  local depfile = $(<) ;
  local plugin = $(>) ;
  local libname = $(3) ;
  
  local depfile_gristed_plugin = $(depfile:G=$(plugin)) ;
  MakeLocate $(depfile_gristed_plugin) : [ on $(depfile) GetVar LOCATE ] ;
  if $($(depfile).FIRSTTIME) != "yes"
  {
    CreateDepFlagsFile $(depfile_gristed_plugin) ;
    $(depfile).FIRSTTIME = "yes" ;
  }
  WriteDepFlagsPluginAvail $(depfile_gristed_plugin) : $(plugin) ;
  
  local mode arch ;
  for mode in debug release
  {
    for arch in x86 x64
    {
      local depfile_gristed = $(depfile:G=$(plugin)_$(mode)_$(arch)) ;
      MakeLocate $(depfile_gristed) : [ on $(depfile) GetVar LOCATE ] ;
      
      local lflags cflags ;
      if "$(mode)" = "debug"
      {
	# "Artificially" insert static library itself
	lflags += $(MSVC.PREFIX.library_static)$(libname)_d.lib ;
	# Collect other libs
	local libs = [ ResolveLibs $($(plugin).NEEDLIBS) ] ;
	lflags += $(MSVC.PREFIX.library_static)$(libs)_d.lib ;
      }
      else
      {
	# "Artificially" insert static library itself
	lflags += $(MSVC.PREFIX.library_static)$(libname).lib ;
	# Collect other libs
	local libs = [ ResolveLibs $($(plugin).NEEDLIBS) ] ;
	lflags += $(MSVC.PREFIX.library_static)$(libs).lib ;
      }
  
      # Defines
      local l ;
      for l in $($(plugin).EXTERNALLIBS)
      {
	if "$(mode)" = "debug"
	{
	  if $($(l).DEFINES.DEBUG)
	  {
	    cflags += "\"/D $($(l).DEFINES.DEBUG)\"" ;
	  }
	  else
	  {
	    cflags += "\"/D $($(l).DEFINES)\"" ;
	  }
	}
	else
	{
	  cflags += "\"/D $($(l).DEFINES)\"" ;
	}
      }
  
      # Link flags
      lflags += $($(plugin).LFLAGS.$(mode))  ;
      lflags += $($(plugin)_$(mode)_$(arch)_EXTERNALLIBS)  ;
      CFLAGS on $(depfile_gristed) = "$(cflags)" ;
      lflags = [ RemoveDups $(lflags) ] ;
      LFLAGS on $(depfile_gristed) = "$(lflags)" ;
      MODE on $(depfile_gristed) = "$(mode)" ;
      ARCH on $(depfile_gristed) = "$(arch)" ;
  
      WriteDepFlags $(depfile_gristed) : $(plugin) ;
      Depends $(depfile_gristed) : $(depfile_gristed_plugin) ;
      Depends $(depfile) : $(depfile_gristed) ;
      Always $(depfile_gristed) ;
    }
  }
  
  local relaydeps = $($(plugin).RELAYDEPS) ;
  for relaydep in $(relaydeps)
  {
    RELAYDEP on $(depfile_gristed_plugin) = "$(relaydep)" ;
    RELAYLIBS on $(depfile_gristed_plugin) = "$($(plugin).RELAYLIBS.$(relaydep))" ;
    WriteDepRelayLibs $(depfile_gristed_plugin) : $(plugin) ;
  }
  
  Depends $(depfile) : $(depfile_gristed_plugin) ;
  Always $(depfile_gristed_plugin) ;
}

actions CreateDepFlagsFile
{
  cat << EOT > $(<)
# This file is automatically generated to be used together with $(LIBNAME)
# and must be integrated by setting the correct values for the 
# HAVE_STATICDEPS.<package> and <package>.STATICDEPS via MsvcGenConfig.
# Furthermore, this file might require manual updates from the master copy 
# (usually found in the package's source repository) every now and then.
EOT
}

actions WriteDepFlagsPluginAvail
{
  cat << EOT >> $(<)
STATICPLUGINS.AVAILABLE += $(>) ;
EOT
}

actions WriteDepFlags
{
  cat << EOT >> $(<)
STATICPLUGIN.$(>).CFLAGS.$(MODE).$(ARCH).$(MSVC_VERSION) = $(CFLAGS) ;
STATICPLUGIN.$(>).LFLAGS.$(MODE).$(ARCH).$(MSVC_VERSION) = $(LFLAGS) ;
EOT
}

actions WriteDepRelayLibs
{
  cat << EOT >> $(<)
STATICPLUGIN.$(>).RELAYDEPS += $(RELAYDEP) ;
STATICPLUGIN.$(>).RELAYLIBS.$(RELAYDEP) = $(RELAYLIBS) ;
EOT
}

rule RegisterCompileGroups
{
  if $(MSVCGEN.REGISTERED_COMPILE_GROUP.$(<)) != yes
  {
    local i ;
    for i in $(<)_$(MSVC.WORKSPACES)
    {
      MsvcProject $(i) : group ;
    }
    MSVCGEN.REGISTERED_COMPILE_GROUP.$(<) = yes ;
  }
}

rule CompileGroups
{
  local w ;
  for w in $(MSVC.WORKSPACES)
  {
    local i ;
    for i in $(>)_$(w)
    {
      local m  = $($(<)_MSVCNAME) ;
      if ! $(m) { m = $($(<)_$(w)_MSVCNAME) ; } # Might be a "group".
      if $(m)
      {
        ResponseFile $($(w)_WKS_RESPFILE) : "$($(i)_MSVCNAME)|$(m)" :
	  notfile : $($(w)_WKS_RESPDIR) ;
      }
    }
  }
}

rule LinkWith
{
  local libs = [ ResolveLibs $(>) $($(>).NEEDLIBS) ] ;
  LibDepends $(<) : $(libs) ;
}

rule LibDepends
{
  local libs = $(>) ;
  for w in $(MSVC.WORKSPACES)
  {
    local l ;
    for l in $(libs)
    {
      if $($(l)_MSVCNAME)
      {
	ResponseFile $($(w)_WKS_RESPFILE) : "$($(<)_MSVCNAME)|$($(l)_MSVCNAME)" :
	  notfile : $($(w)_WKS_RESPDIR) ;
      }
    }
  }
  local l ;
  for l in $(libs) $($(libs).NEEDLIBS)
  {
    if ! [ IsElem $(l) : $($(<).NEEDLIBS) ]
    {
      ResponseFile $($(<)_PRJ_RESPFILE) : "depends|$($(l)_MSVCNAME)" :
        notfile : $($(<)_PRJ_RESPDIR) ;
      $(<).NEEDLIBS += $(l) ;
    }
  }
  
  ExternalLibs $(<) : $($(>).EXTERNALLIBS) ;
}

rule RelayLibs
{
  local extlib ;
  
  local outdir = [ Property msvcgen : outdir$(MSVC_VERSION) ] ;
  local outdircommon = [ Property msvcgen : outdircommon ] ;
  if "$(outdircommon)" = ""
  {
    outdircommon = $(outdir) ;
  }
  
  for extlib in $(>)
  {
    local relayfile = $(extlib).fake_stub.c ;
    MakeLocate $(relayfile) : $(outdircommon) ;
    WHATEVER on $(relayfile) = $(3) ;
    WriteRelayLibStub $(relayfile) ;
    Depends msvcgen : $(relayfile) ;

    MsvcExtraFile1 $(<) : $(relayfile:R=$(outdircommon)) ;
    
    $(<).RELAYDEPS += $(extlib) ;
    $(<).RELAYLIBS.$(extlib) = $(3) ;
  }

  ExternalLibs $(<) : $(>) ;
}

rule MsvcClassifyMode
{
  local c ;
  switch $(<)
  {
    case release : c = "" ;
    case debug : c = debug ;
    case * : c = "" debug ;
  }
  return $(c) ;
}

rule MsvcClassifyArch
{
  local c ;
  switch $(<)
  {
    case x86 : c = "" ;
    case x64 : c = "-x64" ;
    case * : c = "" "-x64" ;
  }
  return $(c) ;
}

# _MsvcRespEmit target : items : tag [ : mode [ : arch [ : options ]]]
#   Emit `items' to the response file for `target' using the response file tag
#   `tag'. `mode' is either "release", "debug", or empty, in which case it
#   applies to release and debug modes. If options contains "ignoremode", then
#   `mode' is not consulted.
rule _MsvcRespEmit
{
  local target = $(1) ;
  local items = $(2) ;
  local tag = $(3) ;
  local mode = $(4) ;
  local arch = $(5) ;
  local options = $(6) ;
  local modes = "" ;
  local archs = "" ;

  CheckOptions ignoremode ignorearch : $(options) : $(target) ;
  if ! [ IsElem ignoremode ] { modes = [ MsvcClassifyMode $(mode) ] ; }
  if ! [ IsElem ignorearch ] { archs = [ MsvcClassifyArch $(arch) ] ; }

  if "$(target)" = ""
  {
    MSVC.RESPEMIT.GLOBAL += "$(tag)$(modes)$(archs)|$(items)" ;
  }
  else
  {
    ResponseFile $($(target)_PRJ_RESPFILE) : "$(tag)$(modes)$(archs)|$(items)" :
      notfile : $($(target)_PRJ_RESPDIR) ;
  }
}

# MsvcExternalLibrary target [ : libs [ : mode [ : arch ]]]
#   (See documentation above.)
rule MsvcExternalLibrary1
{
  _MsvcRespEmit $(1) : $(2) : library : $(3) : $(4) ;
  local mode = $(3) ;
  mode ?= debug release ;
  local arch = $(4) ;
  arch ?= x86 x64 ;
  $(1)_$(mode)_$(arch)_EXTERNALLIBS += $(2) ;
}

# MsvcDefine target [ : key [ : value [ : mode [ : arch ]]]]
#   (See documentation above.)
rule MsvcDefine1
{
  local target = $(1) ;
  local key = $(2) ;
  local value = $(3) ;
  local mode = $(4) ;
  local arch = $(5) ;
  arch ?= x86 x64 ;
  if $(key)
  {
    local def ;
    if $(value)
    {
      def = "$(key)=$(value)" ;
    }
    else
    {
      def = $(key) ;
    }
    for a in $(arch)
    {
      _MsvcRespEmit $(target) : $(def) : define : $(mode) : $(a) ;
      STATICPLUGINS.$(target).MSVC_DEFINES.$(a) += $(def) ;
    }
  }
}

# MsvcIncDirs target : directory [ : mode [ : arch]]
#   (See documentation above.)
rule MsvcIncDirs1 
{ 
  _MsvcIncDirs $(1) : $(2) : $(3) : $(4) ;
}

## MsvcUsePCH target : file
##   (See documentation above.)
rule MsvcUsePCH1
{
  _MsvcRespEmit $(1) : $(2) : pch ; 
}

# _MsvcDefine target : tuples [ : mode [ : arch ]]
#   Similar to MsvcDefine, but works with a list of `key=value' tuples. Also
#   understands `key' with no value.
rule _MsvcDefine
{
  _MsvcRespEmit $(1) : $(2) : define : $(3) : $(4) ;
}

# MsvcCFlags target [ : cflags [ : mode [ : arch ]]]
#   (See documentation above.)
rule MsvcCFlags1
{
  _MsvcRespEmit $(1) : $(2) : cflags : $(3) : $(4) ;
}

# MsvcLFlags target [ : lflags [ : mode [ : arch ]]]
#   (See documentation above.)
rule MsvcLFlags1
{
  local modes = [ MsvcClassifyMode $(3) ] ;
  $(target).LFLAGS.$(modes) += $(2) ;
  _MsvcRespEmit $(1) : $(2) : lflags : $(3) : $(4) ;
}

# MsvcExtraFile target : files
#   (See documentation above.)
rule MsvcExtraFile1 
{
  local rawname = $(1) ;
  local files = $(2) ;

  local respfile = $($(rawname)_PRJ_RESPFILE) ;
  local respdir = $($(rawname)_PRJ_RESPDIR) ;
  
  MsvcAddFileToProject $(respfile) : $(files) : $(respdir) ;
}

# _MsvcIncDirs target : incdirs [ : mode [ : arch ]]
#   Helper for ExternalLibs which processes the contents of TAG.INCDIRS for
#   an external library.
rule _MsvcIncDirs
{
  _MsvcRespEmit $(1) : $(2) : include : $(3) : $(4) ;
}

# _MsvcLibDirs target : libdirs [ : mode [ : arch ]]
#   Helper for ExternalLibs which processes the contents of TAG.LIBDIRS for
#   an external library.
rule _MsvcLibDirs
{
  _MsvcRespEmit $(1) : $(2) : libdir : $(3) : $(4) ;
}

# _ExternalLibsHelperMsvc target : libtag : subrule : attribute
rule _ExternalLibsHelperMsvc
{
  local target = $(1) ;
  local lib = $(2) ;
  local rulename = $(3) ;
  local attrib = $(4) ;
  local arch_X86 = x86 ;
  local arch_X64 = x64 ;
  
  for a in X86 X64
  {
    if $($(lib).$(attrib).DEBUG.$(a).$(MSVC_VERSION))
    {
      $(rulename) $(target) : $($(lib).$(attrib).DEBUG.$(a).$(MSVC_VERSION)) : debug : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).DEBUG.$(MSVC_VERSION))
    {
      $(rulename) $(target) : $($(lib).$(attrib).DEBUG.$(MSVC_VERSION)) : debug : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).DEBUG.$(a))
    {
      $(rulename) $(target) : $($(lib).$(attrib).DEBUG.$(a)) : debug : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).DEBUG)
    {
      $(rulename) $(target) : $($(lib).$(attrib).DEBUG) : debug : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).$(a))
    {
      $(rulename) $(target) : $($(lib).$(attrib).$(a)) : debug : $(arch_$(a)) ;
    }
    else
    {
      $(rulename) $(target) : $($(lib).$(attrib)) : debug : $(arch_$(a)) ;
    }
    
    if $($(lib).$(attrib).$(a).$(MSVC_VERSION))
    {
      $(rulename) $(target) : $($(lib).$(attrib).$(a).$(MSVC_VERSION)) : release : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).$(MSVC_VERSION))
    {
      $(rulename) $(target) : $($(lib).$(attrib).$(MSVC_VERSION)) : release : $(arch_$(a)) ;
    }
    else if $($(lib).$(attrib).$(a))
    {
      $(rulename) $(target) : $($(lib).$(attrib).$(a)) : release : $(arch_$(a)) ;
    }
    else
    {
      $(rulename) $(target) : $($(lib).$(attrib)) : release : $(arch_$(a)) ;
    }
  }
}

rule ExternalLibs
{
  local i ;
  for i in $(>)
  {
    _ExternalLibsHelperMsvc $(<) : $(i) : MsvcCFlags : CFLAGS ;
    _ExternalLibsHelperMsvc $(<) : $(i) : MsvcLFlags : LFLAGS ;
    _ExternalLibsHelperMsvc $(<) : $(i) : MsvcExternalLibrary : LIBS ;
    _ExternalLibsHelperMsvc $(<) : $(i) : _MsvcDefine  : DEFINES ;
    _ExternalLibsHelperMsvc $(<) : $(i) : _MsvcIncDirs : INCDIRS ;
    _ExternalLibsHelperMsvc $(<) : $(i) : _MsvcLibDirs : LIBDIRS ;
    
    $(<).EXTERNALLIBS += $(i) ;
  }
  
  for target in $($(<).PROPAGATE_EXTERNALLIBS)
  {
    ExternalLibs $(target) : $(>) ;
  }
}

rule IncludeDir
{
  local dir = $(1) ;
  local target = $(2) ;
  local options = $(3) ;

  if ! [ IsElem transient : $(options) ]
  {
    if $(target)
    {
      # IncludeDir for a target must be called _after_ the target was set up,
      # hence we can assume a project response file is present
      local inckeys = "include" includedebug ;
      local relpath = [ Property msvcgen : relpath$(MSVC_VERSION) ] ;
      local respfile = $($(target)_PRJ_RESPFILE) ;
      local respdir = $($(target)_PRJ_RESPDIR) ;
      if [ IsElem literal : $(options) ]
      {
	if $(dir)
	{
	  dir = [ ConcatDirs $(dir) ] ;
	}
	else
	{
	  dir = "." ;
	}

	ResponseFile $(respfile) : "$(inckeys)|$(dir)" : notfile : $(respdir) ;
	ResponseFile $(respfile) : "$(inckeys)-x64|$(dir)" : notfile : $(respdir) ;
      }
      else
      {
	if $(dir)
	{
	  dir = [ ConcatDirs $(relpath) $(SUBDIR_TOKENS) $(dir) ] ;
	}
	else
	{
	  dir = [ ConcatDirs $(relpath) $(SUBDIR_TOKENS) ] ;
	}

	ResponseFile $(respfile) : "$(inckeys)|$(dir)" : notfile : $(respdir) ;
	ResponseFile $(respfile) : "$(inckeys)-x64|$(dir)" : notfile : $(respdir) ;
      }
      
    }
    else
    {
      local tag = "INCDIRS" ;
      if [ IsElem literal : $(options) ] { tag = "INCDIRS_LITERAL" ; }
      if $(dir)
      {
	dir = [ ConcatDirs $(dir) ] ;
      }
      else
      {
	dir = "." ;
      }
      MSVC.$(tag) += $(dir) ;
    }
  }
}

# Normal invocations of these two rules are made using Unix-style flags;
# possibly determined by an Autoconf configuration script.  Such flags are
# unsuitable for MSVC, so we ignore them.
rule CFlags { }
rule LFlags { }

rule Win32Resource
{
  Depends $(<) : $($(<)_RCNAME) ;
  Depends $($(<)_RCNAME) : $(>) ;
  MergeResources $($(<)_RCNAME) : $(>) ;
}

#----------------------------------------------------------------------------

actions MsvcBuildFile
{
  cat > $(<) <<EOF
[% INCLUDE '$(MSVC_BUILD_TYPE)$(MSVC_TEMPLATE_SUFFIX).tlib' respfile='$(>)' -%]
EOF
}

actions together MergeResources
{
  cat $(>) > $(<)
}

actions GenerateIconRc
{
  sedexpr=`echo 's^$(MSVCGEN_STRIP_ROOT)^^;' | $(MSVCGEN_SED_PROTECT)`
  icon=`echo "$(>)" | sed "$sedexpr"`
  echo "1 ICON \"$(RELPATH)$icon\"" > $(<)
}

#----------------------------------------------------------------------------

rule MsvcTTreeRc
{
  local target = $(<:G=ttreerc$(MSVC_VERSION)) ;
  local builddir = [ msvcgen_build_dir $(MSVC_VERSION) ] ;
  local workdir = [ msvcgen_work_dir $(MSVC_VERSION) ] ;

  WORKDIR on $(target) = $(workdir) ;
  BUILDDIR on $(target) = $(builddir) ;

  MakeLocate $(target) : $(workdir) ;
  MsvcTTreeRc1 $(target) ;
  Always $(target) ;
  Depends msvcgenrun : $(target) ;
  MsvcRmTemps msvcgen : $(target) ;

  return $(target) ;
}

actions MsvcTTreeRc1
{
  cat > $(<) <<EOF
lib = $(MSVCGEN_TEMPLATEDIR)
lib = $(WORKDIR)
src = $(BUILDDIR)
dest = $(MSVCGEN_OUTDIR_$(MSVC_VERSION))
suffix $(MSVC.TSUFPRJ)=$(SUFPRJ)
suffix $(MSVC.TSUFWKP)=$(SUFWSP)
EOF
}

#----------------------------------------------------------------------------

rule MsvcTTree
{
  NotFile $(<) ;
  Always $(<) ;
}

if $(MSVC_FORCE_CRLF) = yes
{
  actions MsvcTTree
  {
    $(RUN_TTREE) -f \$(>) $(MSVCGEN_TTREEOPTIONS) --load_perl --all
    $(PERL) -pi.bak \
      -e 'if ($ARGV ne $prev) { $prev = $ARGV; binmode(ARGVOUT) }' \
      -e 's:(?<!\015)\012:\015\012:g' \
      $(MSVCGEN_OUTDIR_$(MSVC_VERSION))/*.$(SUFPRJ) \
      $(MSVCGEN_OUTDIR_$(MSVC_VERSION))/*.$(SUFWSP)
    $(RM) $(MSVCGEN_OUTDIR_$(MSVC_VERSION))/*.bak
  }
}
else
{
  actions MsvcTTree
  {
    $(RUN_TTREE) -f \$(>) $(MSVCGEN_TTREEOPTIONS) --load_perl --all
  }
}

MsvcTTree msvcgenrun : [ MsvcTTreeRc ttree.rc ] ;

NotFile msvcgen ;
Always msvcgen ;
Depends msvcgen : msvcgenrun ;
}
